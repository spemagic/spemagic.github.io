<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="专注于工作协同的IM平台">
<meta property="og:type" content="website">
<meta property="og:title" content="织语移动端">
<meta property="og:url" content="http://www.ccwork.com.cn/index.html">
<meta property="og:site_name" content="织语移动端">
<meta property="og:description" content="专注于工作协同的IM平台">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="织语移动端">
<meta name="twitter:description" content="专注于工作协同的IM平台">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.ccwork.com.cn/"/>





  <title>织语移动端</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">织语移动端</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.ccwork.com.cn/2018/09/17/face recognize/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="织语移动端">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="织语移动端">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/face recognize/" itemprop="url">人脸识别简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-17T16:00:00+08:00">
                2018-09-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/人工智能/" itemprop="url" rel="index">
                    <span itemprop="name">人工智能</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>人脸识别（Face Recognition）是一种依据人的面部特征进行身份识别，定位，查找的一种生物识别技术。生物特征识别技术所研究的生物特征包括脸、指纹、手掌纹、虹膜、视网膜、声音（语音）、体形、个人习惯（例如敲击键盘的力度和频率、签字）等，相应的识别技术就有人脸识别、指纹识别、掌纹识别、虹膜识别、视网膜识别、语音识别（用语音识别可以进行身份识别，也可以进行语音内容的识别，只有前者属于生物特征识别技术）、体形识别、键盘敲击识别、签字识别等。</p>
<h2 id="人脸识别特点"><a href="#人脸识别特点" class="headerlink" title="人脸识别特点"></a>人脸识别特点</h2><p>人脸识别的优点：</p>
<ul>
<li>直观：可以通过观察比较人脸来直接区分和确认身份，具有同类特性的还有语音识别，指纹识别不具备该特性。</li>
<li>非强制性：人脸识别是利用可见光获取人脸图像信息，不同于指纹识别或者虹膜识别需要利用电子压力传感器采集指纹，人为配合才能完成采集。</li>
<li>非接触性：用户在进行人脸识别的时候，并不需要和相关的摄影设备直接接触。</li>
<li>并发性：实际应用场景中，人脸识别技术可以进行多个人脸的分拣、判断及识别。</li>
</ul>
<p>人脸识别的难点：</p>
<ul>
<li>识别率依赖环境：光照环境，人脸图像位置，清晰度，遮挡物等，都会影响识别成功率。</li>
<li>人脸相似性：人类脸部存在相似性，不同个体之间的区别不大，所有的人脸的结构都相似，需要有足够智能的算法来区分出不同个体。</li>
<li>人脸易变性：同样的人脸，也会面临着面部衰老，变化（胡须，眉毛等），人为改变（眼镜，化妆，整容等）等因素，增加识别的难度。</li>
<li>人为因素：通过各种手段，人为的制造模拟的人脸图像（静态图片，3D模型等）。</li>
</ul>
<h2 id="人脸识别步骤"><a href="#人脸识别步骤" class="headerlink" title="人脸识别步骤"></a>人脸识别步骤</h2><p>人脸识别主要流程如下</p>
<p>1.图像采集（Image Capture）</p>
<p>人脸图像分为静态图像和动态图像，静态图像是指照片和静态的纸质图片等，动态图像主要来自于摄像机实时拍摄采集或者已有视频。</p>
<p>2.人脸检测（Face Detection）</p>
<p>人脸检测就是找出图像中所有的人脸</p>
<p><img src="https://raw.githubusercontent.com/dxyoo7/dxyoo7.github.io/hexo/attachment/face_detection/auto_focus.jpg" alt=""></p>
<p>能够实现人脸检测的算法非常多，原理也各不相同。最著名的当属 <a href="https://docs.opencv.org/3.4/d7/d8b/tutorial_py_face_detection.html" target="_blank" rel="noopener">Viola-Jones</a> 在 2001 年提出的算法，他们通过 Haar 特征和 AdaBoost 去训练级联分类器（Cascade Classfier）获得实时效果很好的人脸检测器，检测流程如下：</p>
<ul>
<li><p>图像预处理（将提取到的图片统一大小和灰度化）</p>
<p>  <img src="https://raw.githubusercontent.com/dxyoo7/dxyoo7.github.io/hexo/attachment/face_detection/audrey_hepburn.jpg" alt=""></p>
<p>  一般来说，计算机中的彩色图片都是由若干个色彩通道累积出来的，比如 RGB 模式的图片，有红色通道(Red)，绿色通道(Green)和蓝色通道(Blue)，这三个通道都是灰度图，比如一个点由8位来表示，则一个通道可以表示 2^8=256 个灰度。那样三个通道进行叠加以后可以表3*8=24位种色彩，也就是我们常说的24位真彩。对这样的图片做处理，无疑是一件很复杂的事，所以有必要先将彩色图转为灰度图，那样可以就减少数据量（颜色信息对于人脸识别没有作用）。灰度化和减少图片大小后，数据计算量和资源损耗大大减少，检测速度增加。</p>
</li>
<li><p>构造级联分类器（Cascade Classfier）</p>
<p>  什么是级联的分类器呢？级联分类器是由若干个简单分类器级联成的一个大的分类器，被检测的窗口依次通过每一个分类器，可以通过所有分类器的窗口即可判定为目标区域。</p>
<p>  加载已经训练好的内置模型 haarcascade_frontalface_alt.xml，构建级联分类器。分类器可以加载不同类型的模型，OpenCV 内置了很多模型</p>
<p>  <img src="https://ws1.sinaimg.cn/large/676b2067gy1fvemrhqsj2j20ac0i0wgx.jpg" alt=""></p>
<p>  基础分类器以 Haar特征为输入，以 0/1 为输出，0表示未匹配，1表示匹配。其中 Haar 模型特征分为3种</p>
<p>  <img src="http://dl2.iteye.com/upload/attachment/0014/3392/cce5515b-bd05-32e5-9ce2-12a9cfb839b1.png" alt=""></p>
<ul>
<li>边界特征，包含四种</li>
<li>线性特征，包含8种</li>
<li><p>中心围绕特征，包含两种</p>
<p>分类器可以运用不同的模型对预处理后的图片提取出不同的特征值，特征值是检测人脸的关键数据。不同的模型直接影响检测的成功率，这里用的是 OpenCV 已经训练好的数据模型，不同的厂商可能都会有自己的模型训练方法。</p>
</li>
</ul>
</li>
<li><p>运用 AdaBoost 算法进行检测</p>
<p>  将级联分类器和待检测图片一起 利用 AdaBoost 算法就能检测出图片中是否存在人脸，具体 AdaBoost 算法的原理，相对比较复杂，这里就不介绍了，可以详细查看 <a href="https://en.wikipedia.org/wiki/AdaBoost" target="_blank" rel="noopener">Wikipedia</a>。</p>
</li>
</ul>
<p>iOS 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 图片灰度化</span><br><span class="line">cv::Mat matImage;</span><br><span class="line">UIImageToMat(image, matImage);</span><br><span class="line"></span><br><span class="line">// 转换颜色空间</span><br><span class="line">cv::Mat gray;</span><br><span class="line">cvtColor(matImage, gray, CV_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">// 加载级联器</span><br><span class="line">NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;haarcascade_frontalface_alt&quot; ofType:@&quot;xml&quot;];</span><br><span class="line">cv::CascadeClassifier classifier;</span><br><span class="line">classifier.load(filePath.UTF8String);</span><br><span class="line"></span><br><span class="line">// 运用 AdaBoost 算法进行人脸检测</span><br><span class="line">std::vector&lt;cv::Rect&gt; faces;</span><br><span class="line">classifier.detectMultiScale(gray, faces, 1.1, 2, 0, cv::Size(30, 30));</span><br><span class="line"></span><br><span class="line">// 是否包含人脸</span><br><span class="line">BOOL hasFace = faces.size() &gt; 0;</span><br></pre></td></tr></table></figure>
<p>3.人脸校准（Face Alignment）</p>
<p>人脸校准是给一张脸，找出特征点的位置，比如鼻子左侧，鼻孔下侧，瞳孔位置，上嘴唇下侧等等点的位置，如下图：</p>
<p><img src="http://origin-images0.cnblogs.com/blog/537106/201504/052157319606741.png" alt=""></p>
<p>图中红色的框就是在做 Detection，白色的点就是在做 Alignment。</p>
<p><img src="https://raw.githubusercontent.com/dxyoo7/dxyoo7.github.io/hexo/attachment/face_detection/landmark_68_point.jpg" alt=""></p>
<p>找到人脸上68个普遍存在的点（称为特征点，landmark）</p>
<ul>
<li>下巴轮廓17个点 [0-16]</li>
<li>左眉毛5个点 [17-21]</li>
<li>右眉毛5个点 [22-26]</li>
<li>鼻梁4个点 [27-30]</li>
<li>鼻尖5个点 [31-35]</li>
<li>左眼6个点 [36-41]</li>
<li>右眼6个点 [42-47]</li>
<li>外嘴唇12个点 [48-59]</li>
<li>内嘴唇8个点 [60-67]</li>
</ul>
<p>就可以知道眼睛和嘴巴在哪儿了，后续将图片进行旋转，缩放和错切，使得眼睛和嘴巴尽可能的靠近中心，人脸基本上就对齐了，经过校准之后人脸的识别率会更高。</p>
<p>4.人脸识别（Face Identification）</p>
<p>人脸识别这一块变数是最大的，有相对简单的离线方案，仅仅需要内置一些基础的样本数据，利用相关的算法就可以实现简单的识别功能。但这种方式实现的功能相对较弱，漏检率较高。另一种相对完善的方案是通过后台大数据配合深度学习，对统一实体自动构建出多种多样的数据模型，包括正面和反面的数据模型，来提高识别成功率。OpenCV 自带了三个人脸识别算法：Eigenfaces，Fisherfaces 和局部二值模式直方图 (LBPH)。这些算法都可以进行深度学习。</p>
<h2 id="活体检测"><a href="#活体检测" class="headerlink" title="活体检测"></a>活体检测</h2><p>人脸检测方法多种多样，但所有的方法都会面临着各种各样的欺诈手段，常见的3种为：</p>
<ul>
<li>合法的用户人脸照片</li>
<li>合法的用户人脸视频</li>
<li>合法的用户3D模型或者面具头套</li>
</ul>
<p>面对这些欺诈手段时，一般采用活体检测技术来解决，活体检测实现的手段多种多样：</p>
<ul>
<li>基于运动检测，常见的有眨眼，动嘴等，该方式用户交互成本较高，欺诈成本较低。</li>
<li>基于微纹理，利用假人脸经过二次采集后呈现与真实人脸的纹理差异检测</li>
<li>基于多光谱，基于皮肤和其他材质在光谱放射率上的差异检测</li>
</ul>
<p>目前大部分免费或者开源的人脸识别代码库都不带活体检测功能，这里收集了一些开源代码备用</p>
<p><a href="https://github.com/opencv/opencv_contrib" target="_blank" rel="noopener">opencv_contrib</a></p>
<p><a href="https://github.com/June0611/EyeBlickCheck" target="_blank" rel="noopener">EyeBlickCheck</a></p>
<p><a href="https://github.com/zeusees/Zeusee-Face-Anti-spoofing" target="_blank" rel="noopener">Zeusee-Face-Anti-spoofing</a></p>
<h2 id="行业现状"><a href="#行业现状" class="headerlink" title="行业现状"></a>行业现状</h2><p>人脸识别系统的研究始于20世纪60年代，80年代后随着计算机技术和光学成像技术的发展得到提高，而真正进入初级的应用阶段则在90年后期。人脸识别系统成功的关键在于是否拥有尖端的核心算法，并使识别结果具有实用化的识别率和识别速度。国内的人脸识别企业较多，下图列举了目前人脸识别排行榜前几位的企业</p>
<p><img src="https://ws1.sinaimg.cn/large/676b2067gy1fveu47yp43j20m20onhcc.jpg" alt=""></p>
<p>其中前四家企业细分领域如下图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8484039-dd9de8a294b0ad9b.png?imageMogr2/auto-orient/" alt=""></p>
<p>主要客户对比</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8484039-2877bbf6e2eaddf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/681/format/webp" alt=""></p>
<p>盈利模式</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8484039-14de0910613d6e0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/720/format/webp" alt=""></p>
<h2 id="企业开放-SDK"><a href="#企业开放-SDK" class="headerlink" title="企业开放 SDK"></a>企业开放 SDK</h2><p>企业开放的人脸识别 SDK 分为在线和离线两种方案，在线方案以服务端为主，通过服务端对接 SDK 提供的 API，客户端只需要跟自己的服务端交互即可。这种方案适合服务端资源较充裕，而且对人脸识别及时性要求不是非常高的情况下使用。同时服务端可以充分利用大数据和深度学习相结合，发展出更多的应用场景。离线方案，是指客户端直接嵌入 SDK 供应商提供的离线 SDK，不需要与服务器交互，直接能够获取到识别后的结果。该方案使用场景较单一，适合轻量级接入到客户端，不依赖网络。</p>
<p>下面是部分人脸识别厂商的对比</p>
<table>
<thead>
<tr>
<th>企业</th>
<th>公开提供 SDK</th>
<th>支持离线 SDK</th>
<th>收费方案</th>
<th>产品缺陷</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.faceplusplus.com.cn/face-compare-sdk/tech-specs-pricing/" target="_blank" rel="noopener">旷视</a>（Face++）</td>
<td>是</td>
<td>是</td>
<td>单平台按年收费</td>
<td>暂无</td>
</tr>
<tr>
<td><a href="https://www.sensetime.com/index/apply/index" target="_blank" rel="noopener">商汤</a>（SenseTime）</td>
<td>否</td>
<td>是</td>
<td>未公开</td>
<td>暂无</td>
</tr>
<tr>
<td><a href="http://www.cloudwalk.cn/sdkplus.html" target="_blank" rel="noopener">云从</a></td>
<td>是</td>
<td>是</td>
<td>未公开</td>
<td>暂无</td>
</tr>
<tr>
<td><a href="http://www.yitutech.com/case/" target="_blank" rel="noopener">依图</a></td>
<td>否</td>
<td>是</td>
<td>未公开</td>
<td>暂无</td>
</tr>
<tr>
<td><a href="https://ai.baidu.com/tech/face/offline-sdk" target="_blank" rel="noopener">百度</a></td>
<td>是</td>
<td>是</td>
<td>按授权码个数收费</td>
<td>iOS 端不支持离线 SDK</td>
</tr>
<tr>
<td><a href="https://open.youtu.qq.com/legency/#/develop/new-platform" target="_blank" rel="noopener">腾讯优图</a></td>
<td>是</td>
<td>否</td>
<td>按 API 调用次数收费</td>
<td>不支持离线 SDK</td>
</tr>
<tr>
<td><a href="https://help.aliyun.com/document_detail/53379.html?spm=a2c4g.11174283.6.546.17615d0djnUjEi" target="_blank" rel="noopener">阿里云</a></td>
<td>是</td>
<td>否</td>
<td>按 API 调用次数收费</td>
<td>不支持离线 SDK</td>
</tr>
<tr>
<td><a href="http://www.arcsoft.com.cn/index.html" target="_blank" rel="noopener">虹软</a>（ArcSoft）</td>
<td>是</td>
<td>是</td>
<td>永久免费、闭源（每年授权一次）</td>
<td>识别率一般，活体检测功能只在 Android 端公测</td>
</tr>
</tbody>
</table>
<h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><p><a href="https://github.com/opencv/opencv" target="_blank" rel="noopener">OpenCV</a></p>
<p>OpenCV 是一个基于 BSD 许可（开源）发行的跨平台计算机视觉库，包括人机互动，图像分割，人脸识别，机器视觉等应用领域的开源成果。</p>
<p><a href="https://github.com/cmusatyalab/openface" target="_blank" rel="noopener">OpenFace</a> </p>
<p>基于 <a href="https://github.com/davidsandberg/facenet" target="_blank" rel="noopener">FaceNet</a> 和 OpenCV 的实现的 OpenFace 开源库，是用 Python 开发的服务端程序。OpenFace 最主要的特色是依赖大数据进行基于深度神经网络的学习。</p>
<p><a href="https://github.com/seetaface/SeetaFaceEngine" target="_blank" rel="noopener">SeetaFace</a> </p>
<p>中科院 <a href="http://iip.ict.ac.cn/members/shiguang-shan" target="_blank" rel="noopener">山世光</a> 老师开源，包含人脸检测，人脸对齐，人脸识别三个模块。基于 OpenCV 开发，同时对算法做了一些改进。但是在人脸检测速度上相对较慢，漏检率较高，这里有<a href="https://blog.csdn.net/qq_14845119/article/details/52641735" target="_blank" rel="noopener">实测样本</a>。</p>
<h2 id="开源方案商业化落地的缺陷"><a href="#开源方案商业化落地的缺陷" class="headerlink" title="开源方案商业化落地的缺陷"></a>开源方案商业化落地的缺陷</h2><ul>
<li>漏检率较高</li>
<li>1 : N （多人识别）的识别率较低，识别较慢</li>
<li>活体检测功能较弱</li>
<li>离线方案没有深度学习能力</li>
</ul>
<h2 id="Demo演示"><a href="#Demo演示" class="headerlink" title="Demo演示"></a>Demo演示</h2><p><a href="https://github.com/asjec/ArcFace" target="_blank" rel="noopener">ArcFaceDemo</a></p>
<h2 id="行业应用和产品落地讨论"><a href="#行业应用和产品落地讨论" class="headerlink" title="行业应用和产品落地讨论"></a>行业应用和产品落地讨论</h2><p>有了上面的技术探索和实践，大家可以讨论一下，人脸识别在织语产品上的落地方案。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.ccwork.com.cn/2018/03/25/织语 iOS Hybrid 框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="织语移动端">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="织语移动端">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/25/织语 iOS Hybrid 框架/" itemprop="url">织语 iOS Hybrid 框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-25T15:36:25+08:00">
                2018-03-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hybrid开发/" itemprop="url" rel="index">
                    <span itemprop="name">Hybrid开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hybrid 作为一种混合开发模式，依赖 Native 端的 Web 容器（UIWebView / WKWebView），上层使用 H5、JS 做业务开发。这种开发模式，非常有利于办公协同APP的开放平台搭建，由 Native 端提供API，供第三方使用开发、快速迭代。</p>
<h2 id="Hybrid-APP-框架"><a href="#Hybrid-APP-框架" class="headerlink" title="Hybrid APP 框架"></a>Hybrid APP 框架</h2><p>一个完整的 Hybrid APP 框架主要包括 Manager、WebView 、Bridge、Cache 等模块。整个框架设计理念是组合，而不是继承，因此框架设计的不是一个 XXWebView / XXWebViewController 基类，使用者不需要在业务代码中继承 WebView 。框架设计的是一个 Manager 对象，使用者只需要跟自己业务中的任意一种 WebView 进行绑定，就可以拥有 Hybrid 的能力。</p>
<ul>
<li><p>Manager 作为核心，负责处理 Hybrid 业务，校验和注册API</p>
</li>
<li><p>WebView 作为容器，负责展示前端页面，响应前端交互</p>
</li>
<li><p>Bridge 作为桥梁，负责 Native 和 JS 之间通信交互</p>
</li>
<li><p>Cache 作为缓存，负责缓存资源文件等</p>
</li>
</ul>
<p>框架结构如下：</p>
<p><img src="http://o8anxf7e1.bkt.clouddn.com/Hybrid%E6%A1%86%E6%9E%B6.png" alt="Hybrid 框架"></p>
<h2 id="WebView-容器"><a href="#WebView-容器" class="headerlink" title="WebView 容器"></a>WebView 容器</h2><p>iOS8 以后苹果推出了一套新的 WKWebView，对于 UIWebView 和 WKWebView 的区别，可以参考 <a href="https://mp.weixin.qq.com/s?__biz=MzI1MTE2NTE1Ng==&amp;mid=2649516616&amp;idx=1&amp;sn=c16a7fc0ddaee2a6d5e1ad10373af9e3&amp;chksm=f1efeac3c69863d5942da9ba250c39e29af97a7c1ac22fce49d65dc3967c49c811b0f566b2c6#rd" target="_blank" rel="noopener">教你使用 WKWebView 的正确姿势</a>，本框架暂时选用 WKWebView 作为容器，针对 WKWebView 的问题，本框架做了以下解决方案：</p>
<h4 id="Cookie-问题"><a href="#Cookie-问题" class="headerlink" title="Cookie 问题"></a>Cookie 问题</h4><p>前端抛弃对 Cookie 的依赖，改为使用 H5 的 Storage 能力。另 Native 提供存读接口，以备前端使用存储功能。</p>
<h4 id="NSURLProtocol-支持"><a href="#NSURLProtocol-支持" class="headerlink" title="NSURLProtocol 支持"></a>NSURLProtocol 支持</h4><p>WKWebView 包含一个 <code>browsingContextController</code> 属性对象，该对象提供了 <code>registerSchemeForCustomProtocol</code> 和 <code>unregisterSchemeForCustomProtocol</code> 两个方法，能通过注册 scheme 来代理同类请求，符合注册 scheme 类型的请求会走 NSURLProtocol 协议。但是这种方案存在两个严重缺陷：post 请求 body 数据被清空；对 ATS 支持不足。</p>
<h4 id="跨域访问"><a href="#跨域访问" class="headerlink" title="跨域访问"></a>跨域访问</h4><p>iOS9 以后，可以通过 KVC 设置 <code>WKPreferences</code> 的 <code>allowFileAccessFromFileURLs</code> 和 <code>allowUniversalAccessFromFileURLs</code> 属性，来打开跨域访问。但是 iOS8 暂不支持。</p>
<h4 id="Crash-白屏问题"><a href="#Crash-白屏问题" class="headerlink" title="Crash 白屏问题"></a>Crash 白屏问题</h4><p>在 WKWebView 白屏的时候，<code>webView.title</code> 会被置空，因此，可以在 <code>viewWillAppear</code> 的时候检测 <code>webView.title</code> 是否为空来 reload 页面。</p>
<h4 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h4><p>针对单个资源文件，可以对该资源地址加时间戳避开缓存。针对全局资源文件，需要手动清理缓存，iOS9 以后，系统提供了缓存管理接口 <code>WKWebsiteDataStore</code>。而 iOS8，只能通过手动删除文件来解决了，WKWebView 的缓存数据会存储在 <code>~/Library/Caches/BundleID/WebKit/</code> 目录下，可通过删除该目录来实现清理缓存。</p>
<h2 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h2><p>由于容器选择是 WKWebView，所以 JS 调用 Native 端有两种方式 <code>URL拦截</code> 和 <code>messageHandler</code> 。下图为两种方式性能对比</p>
<p><img src="http://o8anxf7e1.bkt.clouddn.com/%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94.png" alt="性能对比"></p>
<p><code>messageHandler</code> 对比 <code>URL拦截</code> 性能大约提升了 20%，受益于 WKWebView，本框架采用 <code>messageHandler</code> + <code>evaluatingJavaScript</code> 的方式进行通信交互。</p>
<h4 id="JS-gt-Native"><a href="#JS-gt-Native" class="headerlink" title="JS -&gt; Native"></a>JS -&gt; Native</h4><h5 id="Native-注入对象"><a href="#Native-注入对象" class="headerlink" title="Native 注入对象"></a>Native 注入对象</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//配置对象注入</span><br><span class="line">[self.webView.configuration.userContentController addScriptMessageHandler:self name:@&quot;nativeObject&quot;];</span><br><span class="line">//移除对象注入</span><br><span class="line">[self.webView.configuration.userContentController removeScriptMessageHandlerForName:@&quot;nativeObject&quot;];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果当前 WebView 没用了，需要先移除这个对象注入，否则会造成内存泄漏，WebView 和所在 VC 循环引用，无法销毁。</p>
</blockquote>
<h5 id="JS-调用"><a href="#JS-调用" class="headerlink" title="JS 调用"></a>JS 调用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//准备要传给native的数据，包括指令，数据，回调等</span><br><span class="line">var data = &#123;</span><br><span class="line">    action:&apos;xxxx&apos;,</span><br><span class="line">    params:&apos;xxxx&apos;,</span><br><span class="line">    callback:&apos;xxxx&apos;,</span><br><span class="line">&#125;;</span><br><span class="line">//传递给客户端</span><br><span class="line">window.webkit.messageHandlers.nativeObject.postMessage(data);</span><br></pre></td></tr></table></figure>
<h5 id="Native-接收调用"><a href="#Native-接收调用" class="headerlink" title="Native 接收调用"></a>Native 接收调用</h5><p>当 JS 开始调用后，会调用到指定的 WKScriptMessageHandler 代理对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &#123;</span><br><span class="line">    //1 取出 name 是否与注入 name 匹配</span><br><span class="line">    if (message.name isEqualToString:@&quot;nativeObject&quot;) &#123;</span><br><span class="line">        //2 取出对象，做后续操作</span><br><span class="line">        NSDictionary *msgBody = message.body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Native-gt-JS"><a href="#Native-gt-JS" class="headerlink" title="Native -&gt; JS"></a>Native -&gt; JS</h4><p>对于 WKWebView ，除了<code>evaluatingJavaScript</code>，还有 WKUserScript 这个方式可以执行 JS 代码，他们之间是有区别的</p>
<ul>
<li><p><code>evaluatingJavaScript</code> 是在客户端执行这条代码的时候立刻去执行当条JS代码</p>
</li>
<li><p>WKUserScript 是预先准备好JS代码，当 WKWebView 加载 Dom 的时候，执行当条 JS 代码</p>
</li>
</ul>
<p>很明显这个虽然是一种通信方式，但并不能随时随地进行通信，并不适合选则作为设计 Bridge 的核心方案。</p>
<h4 id="注入时机"><a href="#注入时机" class="headerlink" title="注入时机"></a>注入时机</h4><p>并不是所有前端页面都需要用到 Native 能力，因此在需要用到 Native 能力的页面，才注入 JS 代码，为其提供 Native 能力。与前端约定，如果需要，就假跳转至一个指定的 <code>URL</code>, 然后客户端在代理方法 <code>webView:(WKWebView *)webViewdecidePolicyForNavigationAction:decisionHandler:</code> 里判断 <code>URL</code> 是否为指定的 <code>URL</code>，如果是，则执行注入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123;</span><br><span class="line">    NSURL *url = navigationAction.request.URL;</span><br><span class="line">    if ([url.absoluteString isEqualToString:@&quot;指定URL&quot;]) &#123;</span><br><span class="line">        // 执行注入 JS 代码</span><br><span class="line">        </span><br><span class="line">        decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    decisionHandler(WKNavigationActionPolicyAllow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Bridge-框架"><a href="#Bridge-框架" class="headerlink" title="Bridge 框架"></a>Bridge 框架</h4><p>整个 Native 和 JS 的 Bridge 交互流程如下图所示：</p>
<p><img src="http://o8anxf7e1.bkt.clouddn.com/bridge%E6%B5%81%E7%A8%8B.png" alt="brdige流程"></p>
<p>在 Native / JS 端，创建 Bridge 对象，该对象需包含：</p>
<h5 id="property"><a href="#property" class="headerlink" title="property"></a>property</h5><ul>
<li>messageHandlers 字典，以 handlerName 作为 key，保存对应 function</li>
<li>responseCallbacks 字典，以 callbackId 作为 key，保存响应 function</li>
</ul>
<h5 id="function"><a href="#function" class="headerlink" title="function"></a>function</h5><ul>
<li>doSend: 调用另一端方法，传递 message 字典参数</li>
<li>responseAnotherMethod: 响应另一端的调用，接收 message 字典参数</li>
</ul>
<h2 id="Manager"><a href="#Manager" class="headerlink" title="Manager"></a>Manager</h2><p>Manager 为整个 Hybrid 核心，负责 JS 方法到 Native 端的映射，可灵活扩展。利用 runtime 特性，使用得到的 className 和 functionName 反射出指定的对象，并执行指定函数。</p>
<h4 id="权限验证"><a href="#权限验证" class="headerlink" title="权限验证"></a>权限验证</h4><p>针对打开的 WebView, 是否拥有合法使用 Hybrid 的权限需要进行验证，只有验证通过的页面，才能使用原生提供的能力。Manager 提供入口，具体验证由上层实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)authenticationSignatureParameter:(NSDictionary *)parameter comlete:(void (^)(NSError *error))complete;</span><br></pre></td></tr></table></figure>
<h4 id="组件协议"><a href="#组件协议" class="headerlink" title="组件协议"></a>组件协议</h4><p>JS 页面加载完，在使用 Native 能力之前，需要进行注册，即告知 Native 当前页面所需要使用的 API 列表。Manager 处理该流程，验证 Native 是否实现该 API，同时把 API 转换成对象，对象遵循以下协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@protocol KKWebViewJSApiBaseProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@required</span><br><span class="line">/// api名字</span><br><span class="line">@property (nonatomic, copy) NSString *apiName;</span><br><span class="line">/// 是否支持js多次回调</span><br><span class="line">@property (nonatomic, assign) NSInteger isNeedRegistId;</span><br><span class="line">/// 是否为事件类型，客户端调用，类似发通知给JS</span><br><span class="line">@property (nonatomic, assign) NSInteger isEvent;</span><br><span class="line">/// api接口参数数据</span><br><span class="line">@property (nonatomic, strong) NSDictionary *paramData;</span><br><span class="line">/// api接口响应回调</span><br><span class="line">@property (nonatomic, copy) WVJBResponseCallback responseCallback;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) KKWebViewJavaScriptManager *jsManager;</span><br><span class="line"></span><br><span class="line">@end;</span><br></pre></td></tr></table></figure>
<h4 id="反射函数"><a href="#反射函数" class="headerlink" title="反射函数"></a>反射函数</h4><p>Manager 把 API 转换成对象时，利用 Objective-C 的 runtime 反射机制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Class cls = NSClassFromString(className);</span><br><span class="line">if ([cls conformsToProtocol:@protocol(KKWebViewJSApiBaseProtocol)]) &#123;</span><br><span class="line">    id&lt;KKWebViewJSApiBaseProtocol&gt; obj = [[cls alloc] init];</span><br><span class="line">    if ([obj respondsToSelector:NSSelectorFromString(functionName)]) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">        [obj performSelector:NSSelectorFromString(functionName)];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">        return obj;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;function is not found&quot;);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    NSLog(@&quot;clss is not found&quot;);</span><br><span class="line">     return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://github.com/cozelight/JSSDK" target="_blank" rel="noopener">Demo链接</a></p>
</blockquote>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTE2NTE1Ng==&amp;mid=2649516616&amp;idx=1&amp;sn=c16a7fc0ddaee2a6d5e1ad10373af9e3&amp;chksm=f1efeac3c69863d5942da9ba250c39e29af97a7c1ac22fce49d65dc3967c49c811b0f566b2c6#rd" target="_blank" rel="noopener">教你使用 WKWebView 的正确姿势</a></p>
<p><a href="https://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA" target="_blank" rel="noopener">WKWebView 那些坑</a></p>
<p><a href="http://www.cnblogs.com/yexiaochai/p/4921635.html" target="_blank" rel="noopener">浅谈Hybrid技术的设计与实现</a></p>
<p><a href="https://lvwenhan.com/ios/460.html" target="_blank" rel="noopener">自己动手打造基于 WKWebView 的混合开发框架</a></p>
<p><a href="http://blog.csdn.net/byeweiyang/article/details/75102051" target="_blank" rel="noopener">58 同城 iOS 客户端 Hybrid 框架探索</a></p>
<p><a href="http://awhisper.github.io/2018/01/02/hybrid-jscomunication/" target="_blank" rel="noopener">从零收拾一个hybrid框架</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.ccwork.com.cn/2018/03/21/code-review-practise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="织语移动端">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="织语移动端">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/21/code-review-practise/" itemprop="url">小团队Code Review实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-21T15:36:25+08:00">
                2018-03-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/代码管理/" itemprop="url" rel="index">
                    <span itemprop="name">代码管理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>引入Code Review的想法，预谋已久。除了希望提高代码质量之外，还有以下目的：</p>
<ul>
<li>提前发现代码中的低端错误和潜在Bug</li>
<li>培养开发者良好的编程习惯，促进技术提高</li>
</ul>
<h2 id="工具选取"><a href="#工具选取" class="headerlink" title="工具选取"></a>工具选取</h2><p>由于项目本身已经托管在内网的Gitlab上，所以优先考虑的是直接利用Gitlab为平台进行代码Review。Gitlab官网演示了基本的<a href="https://about.gitlab.com/2017/03/17/demo-mastering-code-review-with-gitlab/" target="_blank" rel="noopener">代码Review流程</a>，基本流程如下：</p>
<ul>
<li>开发者在Feature分支上修改代码，需要提交时，新建Merge Request，指定Review人员</li>
<li>Review人员收到Merge Request后，进行代码Review</li>
<li>Review通过，Merge Request指派给具有合并分支权限的人员进行Merge</li>
<li>Review不通过，拒绝Merge Request，重复上述步骤</li>
</ul>
<p>这一套流程实践下来的问题是：</p>
<ul>
<li>每次Push代码之后需要开发者手动创建Merge Request（当然可以通过脚本进行自动化，但需要额外配置），然后进行代码Review，不是很方便。</li>
<li>团队内使用标准的<a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">Git Flow</a>，大量开发工作在Feature分支进行。Gitlab无法对每个新建的Feature分支自动添加权限控制，也就无法强制对Feature分支进行Code Review。</li>
</ul>
<p>在Gitlab无法满足团队需求的情况下，继续寻找替代方案。目前比较流行的Code Review平台，主要是Google出品的<a href="https://gerrit-review.googlesource.com/Documentation/" target="_blank" rel="noopener">Gerrit</a>和Facebook出品的<a href="https://secure.phabricator.com/book/phabricator/" target="_blank" rel="noopener">Phabricator</a>，二者都已开源。</p>
<p>Phabricator对比Gerrit有如下优势：</p>
<ul>
<li>界面美观（在工具使用非常频繁的情况下，美观度也是非常重要的）</li>
<li>功能齐全（Phabricator除了代码托管和Code Review之外，还集成了任务、Wiki、日程等）</li>
<li>提供两种不同的Review方式，团队可以灵活切换</li>
<li>能够集成各种自动化插件</li>
</ul>
<p>当然，Phabricator相对Gitlab也有缺点：</p>
<ul>
<li>代码托管方面不如Gitlab专业（也不弱，但不够专业）</li>
<li>部署和使用成本较高（环境配置复杂，命令行较多，对于非开发人员使用成本较高）</li>
</ul>
<p>但这些缺点对研发团队来说都不是硬伤，可以想办法解决，所以最后决定使用Phabricator。</p>
<h2 id="Phabricator实战"><a href="#Phabricator实战" class="headerlink" title="Phabricator实战"></a>Phabricator实战</h2><h3 id="服务端部署"><a href="#服务端部署" class="headerlink" title="服务端部署"></a>服务端部署</h3><p>服务端的部署主要由运维团队支持，这里就不详细介绍了（如有需求，后续由运维团队进行详细介绍）。部署成功后界面如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/21/16247d2ac5574004?w=1298&amp;h=930&amp;f=jpeg&amp;s=275212" alt=""></p>
<h3 id="Web端功能简介"><a href="#Web端功能简介" class="headerlink" title="Web端功能简介"></a>Web端功能简介</h3><p>Phabricator支持Code Review、任务、代码托管、审计、Wiki等各种协同开发工具，非常适合小团队使用。</p>
<h3 id="安装客户端环境"><a href="#安装客户端环境" class="headerlink" title="安装客户端环境"></a>安装客户端环境</h3><p>Phabricator Code Review需要两个库支持:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/phabricator</span><br><span class="line">cd ~/phabricator</span><br><span class="line">git clone https://github.com/phacility/arcanist.git</span><br><span class="line">git clone https://github.com/phacility/libphutil.git</span><br></pre></td></tr></table></figure></p>
<p>arcanist 主要用来做代码的修改和提交，libphutil 是配套工具库，用来做代码语法检查等。安装完成后，设置环境变量，方便全局使用 arc 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:&quot;~/phabricator/arcanist/bin/arc&quot;</span><br></pre></td></tr></table></figure></p>
<p>这样客户端环境就搭建完成了。</p>
<h3 id="初始化设置"><a href="#初始化设置" class="headerlink" title="初始化设置"></a>初始化设置</h3><ul>
<li>创建Admin账号，默认第一个登录的为Admin</li>
<li>设置用户的注册规则和登录认证方式（注册设置为只能以公司域名结尾的邮箱才能注册，登录采用用户名+密码的认证方式，依据实际情况设置）</li>
<li>设置服务端邮件发送参数（后续所有的Review信息都会通过邮件通知）</li>
<li>设置代码仓库读写方式（支持SSH方式，用户需要在设置里上传自己的SSH公钥，支持HTTP方式，需要设置拉取代码必须的VCS密码）</li>
</ul>
<h3 id="仓库管理"><a href="#仓库管理" class="headerlink" title="仓库管理"></a>仓库管理</h3><p>设置完成后，开始迁移旧仓库代码，首先在Phabricator上创建新仓库</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/21/16247fedbdb96067?w=1138&amp;h=662&amp;f=jpeg&amp;s=218113" alt=""><br>编辑URIs：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/21/16248042b5677ddc?w=904&amp;h=270&amp;f=jpeg&amp;s=91259" alt=""><br>将 I/O 修改为 No I/O。</p>
<p>选择New URI添加旧代码的git仓库地址，I/O Type选择Observe模式。</p>
<p>右边Set Credential添加SSH认证（有效公钥）或者HTTP认证（有拉取旧代码权限的用户名和密码）</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/21/1624809605655bff?w=564&amp;h=127&amp;f=jpeg&amp;s=47026" alt=""><br>设置好仓库之后，回到Basics页面，在Actions中选择Activate Repository激活仓库。</p>
<p>如果参数都正常的话，过一段时间就会将原仓库的代码都同步到Phabricator服务器上。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/21/162480d819d8ec7d?w=563&amp;h=206&amp;f=jpeg&amp;s=76884" alt=""></p>
<p>同步完成后，将新仓库代码 clone 到本地。如果代码在本地已经存在，需要修改remote url指向新的url：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin ssh://domain/testdemo.git</span><br></pre></td></tr></table></figure></p>
<p>同时在仓库中添加配置文件 .arcconfig，.arcconfig 文件是一个放置在项目的根目录的 JSON 文件。：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"phabricator.uri"</span>  : <span class="string">"http://your.phabricator.domain"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以设置全局的配置 etc/arcconfig，如果本地仓库没有配置文件，默认会读取全局配置。<br>这里只设置了 phabricator.uri（安装 Phabricator 的 URI），其他详细用法可参考官方文档。</p>
<h3 id="配置Herald强制代码Reivew"><a href="#配置Herald强制代码Reivew" class="headerlink" title="配置Herald强制代码Reivew"></a>配置Herald强制代码Reivew</h3><p>如果希望所有的代码提交都需要Review，可以添加Herald规则。创建新的Herald Rule</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/22/1624ba150c6fd48f?w=803&amp;h=534&amp;f=jpeg&amp;s=112261" alt=""><br>设置好规则，如果没有提交过Differential Revision，禁止Push代码到服务器。</p>
<h3 id="Review流程"><a href="#Review流程" class="headerlink" title="Review流程"></a>Review流程</h3><p>传统的Review流程：</p>
<ul>
<li>开发者修改代码（Write）</li>
<li>本地提交代码（Commit）</li>
<li>Push到服务器（Publish）</li>
<li>代码审核（Review）</li>
<li>通过或者拒绝（Merge or Refuse）</li>
</ul>
<p>Phabricator本身也支持这种Review方式，主要是通过Audit进行提交后Review。这种流程大家都比较熟悉，在这里不做重点介绍，主要介绍另一种Review方式：</p>
<ul>
<li>开发者修改代码（Write）</li>
<li>本地提交代码（Commit）</li>
<li>预审核（Pre-Preview）</li>
<li>提交审核通过（Merge -&gt; Publish）</li>
<li>提交被拒绝（Refuse）</li>
</ul>
<p>以Feature分支为例，修改代码，本地提交，Push到远程仓库。由于前面设置了强制Review，所以直接Push会报权限错误：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/22/1624c55a9be38b34?w=407&amp;h=126&amp;f=jpeg&amp;s=60982" alt=""></p>
<p>Phabricator通过 arcanist 进行代码Review，详细用法可以使用<code>arc help</code>命令查看。先用 diff 命令生成Revision：<br><code>arc diff</code><br><img src="https://user-gold-cdn.xitu.io/2018/3/22/1624c68d338d8a91?w=499&amp;h=377&amp;f=jpeg&amp;s=102782" alt=""><br>填好Reviewers，如果需要通知其他人，填好Subscribers。如果本地有 .arclint 文件，diff 过程首先会调用 lint 脚本进行代码分析，生成编译错误或者警告。可以通过 <code>arc linters</code> 命令查看默认支持的 linter，也可以支持第三方或者自己开发的 linter。lint 检查通过后会生成Revision URI：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/22/1624c6aee03fb5de?w=461&amp;h=185&amp;f=jpeg&amp;s=88437" alt=""><br>同时，如果之前邮件系统已经配置好，Reviewers和Subscribers都会收到邮件。在浏览器中打开URI，可以看到相关的修改</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/22/1624c6cf14270f6e?w=1817&amp;h=913&amp;f=jpeg&amp;s=535304" alt=""><br>评论之后，选择<code>Accept Revision</code>，然后提交。Revision状态会变为Accepted，其他人的列表中变为Ready to Land状态。<br><img src="https://user-gold-cdn.xitu.io/2018/3/22/1624c7085c5607ac?w=1514&amp;h=212&amp;f=jpeg&amp;s=66042" alt=""><br>表示Revision Review通过，等待开发者执行 land 命令，提交到远程仓库Merge。开发者收到Review通过的邮件之后，在本地执行 <code>arc land --onto feature/test1</code> 将代码提交到远程仓库。–onto 后面指定需要Merge的远程分支名，如果不填，默认为 master。</p>
<p>land 之后的代码就成功进入了远程仓库，整个Review过程结束。</p>
<h3 id="关于代码格式化"><a href="#关于代码格式化" class="headerlink" title="关于代码格式化"></a>关于代码格式化</h3><p>对于提交仓库的代码是否需要格式化，目前有2种方式：</p>
<p>第一种是在代码进入远程仓库后，通过自动化脚本进行格式化。这是最可靠的格式化方式，但缺点是格式化代码会对部分提交进行修改，造成代码中会多很多冗余的提交，同时修改代码之后还需要自动化系统来保证编译的正确性。</p>
<p>第二种是在客户端预埋脚本，提交代码时如果不符合规范，无法提交成功。这种方式会比第一种方式风险小，但是覆盖面不够广，必须依赖每个客户端都安装脚本。同时格式化脚本的接入，会提高代码提交成本。想想有时候因为部分代码风格的问题，导致代码迟迟不能入库，也是一件很烦人的事（Xcode提供 crtl+i 的快捷方式进行代码格式调整）。</p>
<p>总之，两种方法都有弊病，具体如何抉择，由团队内部根据实际情况来选择。</p>
<h3 id="代码Review控制"><a href="#代码Review控制" class="headerlink" title="代码Review控制"></a>代码Review控制</h3><p>Web方式Review代码的缺点是不适合Review大块代码，同时也没办法像IDE一样进行调试。所以尽量是控制每次提交的量代码量，每天提交代码进行Review。如果积攒了几个月的代码一次性提交，审核者也是一头包，Review效率也会大幅下降。</p>
<p>同一个功能最好是由同一个人Review，这样能保证业务的熟练度和细节的Review粒度。也提倡互相Review代码，而不是长期由Leader或者高级工程师Review，促进所有开发人员的技术成长。</p>
<h3 id="后续目标"><a href="#后续目标" class="headerlink" title="后续目标"></a>后续目标</h3><ul>
<li>与Gitflow无缝配合使用</li>
<li><a href="https://github.com/uber/phabricator-jenkins-plugin#phabricator-jenkins-plugin--" target="_blank" rel="noopener">与已有的Jekins系统对接，实现自动化编译和测试</a></li>
</ul>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://secure.phabricator.com/book/phabricator/" target="_blank" rel="noopener">Phabricator</a></p>
<p><a href="https://secure.phabricator.com/phame/post/view/766/write_review_merge_publish_phabricator_review_workflow/" target="_blank" rel="noopener">Phabricator Review Workflow</a></p>
<p><a href="https://phabricator.webfuns.net/" target="_blank" rel="noopener">Phabricator中文站</a></p>
<p><a href="https://www.jianshu.com/p/b1a75a14638c" target="_blank" rel="noopener">使用Phabricator做为Code Review工具</a></p>
<p><a href="https://www.zhihu.com/question/41089988" target="_blank" rel="noopener">大家的公司的Code Review都是怎么做的？遇到过哪些问题？</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">织语移动端</p>
              <p class="site-description motion-element" itemprop="description">专注于工作协同的IM平台</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">织语移动端</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
